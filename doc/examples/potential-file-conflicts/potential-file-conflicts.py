#!/usr/bin/python 

# Copyright (C) 2012 Ralf Treinen <treinen@debian.org>
#
# This library is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

import argparse
import re
import itertools
import heapq
import os
import sys
import subprocess
import yaml

argparser=argparse.ArgumentParser(
  description="Find packages with potential file conflicts.")
argparser.add_argument('-c',dest='contentsfiles',action='append',required=True,
                       help='set name of the Contents file.')
argparser.add_argument('-o',dest='outdir',action='store',required=True,
                       help='set name of the output directory')
argparser.add_argument('-r',dest='repositories',action='append',required=True,
                       help='add a debian repository (Packages) file')
arguments=argparser.parse_args()

outdir = arguments.outdir
if os.path.exists(outdir):
    raise('directory'+outdir+'already exists')
else:
    os.mkdir(arguments.outdir)

# variables used for statsitics
number_shared_files = 0
number_pairs_sharing = 0
number_pairs_sharing_coinstallable = 0

############################################################################
# read the contentsfile into a dictionary
############################################################################

print 'Scanning the contents files ...',
sys.stdout.flush()
descriptors=map(open,arguments.contentsfiles)

# Skip the preambles in all files
for desc in descriptors:
    while True:
        if re.match('FILE\s*LOCATION\s*',desc.readline()): break

# iterator over the pairs in a file, each pair is a line in the file split
# at whitespace.
def lr_split_file(f):
    for line in f: 
        s=line.rsplit(None,1)
        yield (s[0],s[1])

# table that will associate to a pair of packages a list of common files
filetable = {}

for foundfile, pck_it in itertools.groupby(
    heapq.merge(*[lr_split_file(f) for f in descriptors]),lambda x:x[0]):
    packagelist=[p for p in itertools.chain(
            *map(lambda pl:re.split(',',pl[1]),pck_it))]
    # if packagelist contains only one package then there is no sharing
    # of foundfile. Otherwise we iterate over all pairs that we can build
    # from elements in packagelist, and make an according entry in filetable
    if len(packagelist) > 1:
        number_shared_files += 1
        # strip any section/ or suite/section/ prefix from packagenames.
        foundpackages=sorted(map(lambda s:s[1+s.rfind('/'):],packagelist))
        for pair in itertools.combinations(foundpackages,2):
            if pair not in filetable:
                filetable[pair]=foundfile+'\n'
                number_pairs_sharing += 1
            else:
                filetable[pair] += foundfile+'\n'

for desc in descriptors:
    desc.close()
print 'done.'

###########################################################################
# run debcheck
###########################################################################

invocation='/usr/bin/dose-debcheck --successes'
for repo in arguments.repositories:
    invocation += ' --bg=deb://' + repo

print 'Running dose-debcheck ...',
sys.stdout.flush()
debcheckproc=subprocess.Popen(invocation,shell=True,
                              stdin=subprocess.PIPE,
                              stdout=subprocess.PIPE)

# write the input file for debcheck, containing a pseudo-package for each
# of the pairs (pa,pb) that we found, depending on pa and on pb. We use
# bogus version constraint >=0 to enforce that this dependency can only be
# satisfied by a real package, not a virtual package.
#
# We pipe that input directly into the debcheck process. We use 
for packages,files in filetable.iteritems():
    pa=packages[0]
    pb=packages[1]
    debcheckproc.stdin.write('Package: '+pa+':'+pb+'\n')
    debcheckproc.stdin.write('Version: 1\nArchitecture: all\n')
    debcheckproc.stdin.write('Depends: '+pa+'(>=0), '+pb+'(>=0)\n\n')
debcheckproc.stdin.close()

# read the report generated by debcheck. Since we called debcheck with
# option --successes we get only stanzas that encode co-installable
# pairs of packages.
debreport = yaml.load(debcheckproc.stdout)
print 'done.'
os.chdir(outdir)
if debreport['report'] is not None:
    for stanza in debreport['report'] :
        number_pairs_sharing_coinstallable += 1
        stanzamatch=re.match('^(.*):(.*)',stanza['package'])
        pa,pb=stanzamatch.group(1),stanzamatch.group(2)
        out=open(pa+':'+pb,'w')
        out.write(filetable[(pa,pb)])
        out.close()

#############################################################################
# Report statistics
#############################################################################

print "Number of shared files:",
print number_shared_files
print "Number of pairs of packages sharing a file:",
print number_pairs_sharing
print "Number of coinstallable pairs among these:",
print number_pairs_sharing_coinstallable
