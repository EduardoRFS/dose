#!/usr/bin/python3.2

# Copyright (C) 2012 Ralf Treinen <treinen@debian.org>
#
# This library is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

import argparse, re, yaml
import itertools, heapq
import os, sys, subprocess

# sepchar is used when constructing the name of a pseudo-package that
# encodes the pair of two packages. It should be a character that may
# not appear in the name of a debian package, but that is accepted by
# dose-debcheck in package names.
sepchar='_'

argparser=argparse.ArgumentParser(
  description="Find packages with potential file conflicts.")
argparser.add_argument('-c',dest='contentsfiles',action='append',required=True,
                       help='add a debian Contents file.')
argparser.add_argument('-o',dest='outdir',action='store',required=True,
                       help='set name of the output directory')
argparser.add_argument('-r',dest='repositories',action='append',required=True,
                       help='add a debian repository (Packages) file')
argparser.add_argument('--separator',dest='sepchar',action='store',
                       required=False,
                       help='separator used in  names of pseudo packages')
arguments=argparser.parse_args()

outdir = arguments.outdir
if os.path.exists(outdir):
    print('fatal error: directory \'{0}\' already exists'.format(outdir),
          file=sys.stderr)
    sys.exit(1)
else:
    os.mkdir(arguments.outdir)

if arguments.sepchar is not None:
    sepchar=arguments.sepchar

# variables used for statistics
number_shared_files  = 0  # number of shared files
number_pairs_sharing = 0  # pairs of packages that share at least 1 file
number_pairs_coinst  = 0  # among these pairs that are co-installable

############################################################################
# read the contentsfile into a dictionary
############################################################################

print('Scanning the contents files ...', end=" ")
sys.stdout.flush()
descriptors=[open(f,'r') for f in arguments.contentsfiles]

# Skip the preambles in all files
for desc in descriptors:
    while True:
        if re.match('FILE\s*LOCATION\s*',desc.readline()): break

# iterator over the pairs in a file, each pair is a line in the file split
# at whitespace.
def lr_split_file(f):
    for line in f: 
        s=line.rsplit(None,1)
        yield (s[0],s[1])

# table that will associate to a pair of packages a list of common files
filetable = {}

for foundfile, pck_it in itertools.groupby(
    heapq.merge(*[lr_split_file(f) for f in descriptors]),lambda x:x[0]):
    packagelist=[p for p in itertools.chain(
            *map(lambda pl:re.split(',',pl[1]),pck_it))]
    # if packagelist contains only one package then there is no sharing
    # of foundfile. Otherwise we iterate over all pairs that we can build
    # from elements in packagelist, and make an according entry in filetable
    if len(packagelist) > 1:
        number_shared_files += 1
        # strip any section/ or suite/section/ prefix from packagenames.
        foundpackages=sorted([s[1+s.rfind('/'):] for s in packagelist])
        for pair in itertools.combinations(foundpackages,2):
            if pair not in filetable:
                filetable[pair]=foundfile+'\n'
                number_pairs_sharing += 1
            else:
                filetable[pair] += foundfile+'\n'

for desc in descriptors:
    desc.close()
print('done.')

###########################################################################
# run debcheck
###########################################################################

invocation='/usr/bin/dose-debcheck --successes --latest'
for repo in arguments.repositories:
    invocation += ' --bg=deb://' + repo 

print('Running dose-debcheck ...', end=' ')
sys.stdout.flush()
debcheckproc=subprocess.Popen(invocation,shell=True,
                              stdin=subprocess.PIPE,
                              stdout=subprocess.PIPE)

# write the input file for debcheck, containing a pseudo-package for each
# of the pairs (pa,pb) that we found, depending on pa and on pb. We use
# bogus version constraint >=0 to enforce that this dependency can only be
# satisfied by a real package, not a virtual package.
pseudopackage = """
Package: {pa}{sep}{pb}
Version: 1
Architecture: all
Depends: {pa}(>=0)|{pa}(<0),{pb}(>=0)|{pb}(<0)

"""
for (pa,pb) in filetable.keys():
    debcheckproc.stdin.write(bytes(
            pseudopackage.format(pa=pa,pb=pb,sep=sepchar),'UTF8'))
debcheckproc.stdin.close()

# read the report generated by debcheck. Since we called debcheck with
# option --successes we get only stanzas that encode co-installable
# pairs of packages.
debreport = yaml.load(debcheckproc.stdout)
print('done.')
os.chdir(outdir)
if debreport['report'] is not None:
    for stanza in debreport['report']:
        number_pairs_coinst += 1
        stanzamatch=re.match('^(.*)'+sepchar+'(.*)',stanza['package'])
        pa,pb=stanzamatch.group(1),stanzamatch.group(2)
        out=open(pa+sepchar+pb,'w')
        out.write(filetable[(pa,pb)])
        out.close()

#############################################################################
# Report statistics
#############################################################################

print('Shared files: {0}'.format(number_shared_files))
print('Pairs of packages sharing a file: {0}'.format(number_pairs_sharing))
print('Coinstallable pairs among these: {0}'.format(number_pairs_coinst))
