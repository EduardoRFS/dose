\section{Multi Archictecture in Debian}

In the Multi Architecture context, a Debian system has different notions of
architecture. The \texttt{Native} architecture is the architecture linked to
the package \texttt{dpkg} and is effectively chosen at install time by the user
(for example, a user can choose to have a native architecture i386 on an amd64
machine). \texttt{Foreign} architectures are a list of additional
architectures that are considered by dpkg and apt while resolving dependencies. 
In pre-Multi Architecture system, dependency resolution was restricted to
packages with the same architecture (with the exception of Architecture: all
packages), and a package of the same name but a different architecture was
assumed to not be co-installable. The Multi Architecture specification adds new
binary package field \texttt{Multi-Arch}, to be set on any package wanting to
be installed or used to satisfy dependencies on multiple architectures.

The \texttt{Multi-Arch} field can have four values :

\begin{itemize}
  \item{\texttt{Multi-Arch:Same}.} The package is co-installable with packages
    that have the same name and version, but different architecture,
    but it cannot be used to satisfy dependencies of any package
    with a different architecture of the package itself.

  \item{\texttt{Multi-Arch:Foreign}.} 
    The package is not co-installable with packages
    that have the same name and version, but it can be used to satisfy 
    dependencies of packages with a different architecture of the
    package itself..

    If a package is declared \texttt{Multi-Arch: foreign}, preference
    should be given to a package for the native architecture if
    available; if it is not available, the package manager may
    automatically install any available package, regardless of
    architecture, or it may choose to make this an option controlled
    by user configuration. 

  \item{\texttt{Multi-Arch:Allowed}.}
    The package is not co-installable with packages that have the same
    name and version, but is can be used to satisfy any dependencies
    of the form \texttt{p:any}, where ``any'' is a special decoration
    associated to the dependency constraint. This value exists to
    prevent any packages from incorrectly annotating dependencies as
    being architecture-neutral without coordination with the
    maintainer of the depended-on package. 

  \item{\texttt{Multi-Arch:None}.}
    The package can be installed and used to satisfy dependencies only
    on architectures equal to the architecture of the package itself.
    Packages with \texttt{Multi-Arch: none} have the same semantics of
    pre-multi-architecture packages.
\end{itemize}

A package for a foreign architecture is only installable if all of its
(recursive) dependencies are either marked as \texttt{Multi-Arch} or
do not have corresponding packages installed for the native
architecture. An incomplete \texttt{Multi-Arch} conversion for a given
dependency tree is equivalent to the status-quo. 

Since there are packages that can contain both architecture-specific
and architecture-agnostic components (python, contains that
interpreter that is architecture specific and modules that can be used
on any architecture), the multi-arch specification extend the
dependency relation language with a new attribute (\texttt{p:any})
that declares that a package's dependency on $p$ may be satisfied by a
package of any architecture, so long as the $p$ package declares
itself as \texttt{Multi-Arch:Allowed}. 

A special exception are packages with \texttt{Architecture: all} that
are treated as equivalent to packages of the native architecture for
all dependency resolution. This means that for an Architecture: all
package to satisfy the dependencies of a foreign-architecture package,
it must be marked Multi-Arch: foreign or Multi-Arch: allowed. 

