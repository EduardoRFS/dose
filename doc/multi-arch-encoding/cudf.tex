\subsection{A unified description of upgrades, using CUDF}
\label{sec:cudf}

\subsubsection{Language overview}

A \emph{\CUDF{} document} consists of a sequence of \emph{stanzas},
each of which is a collection of key-value pairs called
\emph{properties}. Properties are typed within a simple \emph{type
system} containing basic data types (integers, booleans, strings) and
more complex, component-specific data types such as boolean formulae
over atomic package constraints used to represent inter-component
relationships.

Each \CUDF{} document is made up of three logical sections: a
\emph{preamble}, a component \emph{universe}, and a \emph{request}.
The universe contains one \emph{component stanza} for each component
known to the package manager.  Both installed and non-installed (but
available) components are represented uniformly in the same document,
in contrast to current platforms which often spread this information
over different locations using different formats.

The properties used in package stanzas may be core properties of the
CUDF format, or extra properties that have been declared in the
preamble of the CUDF document. Properties may have a default value,
and in this case are allowed to be absent from a stanza. The core
properties of CUDF are:
\begin{description}
\item[\PROP{package}] with values of type \texttt{string} denoting the name of
  a package (independent from a particular version).
\item[\PROP{version}] with non-negative integer values denoting the version
  of a package.
\item[\PROP{depends}] with values that are conjunctions of
  disjunctions of atomic package constraints. Dependencies express positive
  context requirements.
\item[\PROP{conflicts}] with values that are lists of atomic package
  constraints. Conflicts express negative context requirements.
\item[\PROP{provides}] with a list of equational package
  constraints. A provided package may be used to satisfy a dependency,
  and has to be taken into account for conflicts.
\item[\PROP{installed}] with boolean values indicating whether the package
  is currently installed or not.
\item[\PROP{keep}] with values indicating whether the package is allowed to
  be removed or updated.
\end{description}

An atomic package constraint consists of a package name and a unary
predicate on version numbers, like the empty predicate (which is true
for all versions), $=17$, $\neq 17$, $> 42$ or $\leq 17$. Equational
package constraints are only allowed to use the empty predicate, or an
equality on the version number like $=25$.

\begin{figure}[t]
  \begin{lstlisting}[style=cudf]
preamble:
property: bugs: int = 0, suite: enum(stable,unstable) = "stable"

package: car
version: 1
depends: engine, wheel > 2, door, battery <= 13
installed: true
bugs: 183

package: bicycle
version: 7
suite: unstable

package: gasoline-engine
version: 1
depends: turbo
provides: engine
conflicts: engine, gasoline-engine
installed: true

...

request:
install: bicycle, gasoline-engine = 1
upgrade: door, wheel > 3
\end{lstlisting}
  \caption{Sample \CUDF{} document}
  \label{fig:cudf-example}
\end{figure}

Figure~\ref{fig:cudf-example} shows a sample \CUDF{} document. The
component universe contains several component stanzas, where both core
and extra properties are used. Extra properties must be declared in
the \emph{preamble}, which starts the document. Extra properties
account for extensibility of the format and enable type checking of
\CUDF{} documents. A \emph{request stanza} encodes the user request
and concludes the document. In its general form, the request stanza
details the components the user wants to
\PROP{install}, \PROP{remove}, or \PROP{upgrade} (using the homonymous
properties), possibly specifying version requirements. The value of such
a request is a list of atomic package constraints.

\ref{sec:cudf-syntax} defines the full syntax of \CUDF{} in form of an
EBNF grammar.

\subsubsection{Overview of CUDF formal semantics}
\label{sec:cudf-semantics-overview}
In order to simplify the description of the semantics we ignore here
the \PROP{keep} property, and take into account only installation and
removal requests (but no upgrade requests). A solution to a CUDF
document $U$ is a subset of the universe of $U$, consisting of the
packages that are installed on a system as a result of the upgrade
operation.  For any subset $S$ of the universe of $U$, let $dom(S)$ be
the set of pairs of package name and version of its packages (in a
valid CUDF document, package name and version uniquely identify a
package). Furthermore, let $pro(S)$ be the set of pairs (name,
version) that are provided by packages in $S$. The version of a
provided package is either the one explicitly mentioned, or any
version in case the version predicate is empty (the set $pro(S)$ may,
as a consequence, be infinite).

One defines easily what it means for a set of pairs (name,version) to satisfy
an atomic package constraint. Then, a subset $S$ of the universe of $U$ is
\begin{itemize}
\item \textbf{abundant} if every disjunction in the dependency of every
  package in $S$ contains a package constraint that is satisfied by
  $dom(S)\cup pro(S)$;
\item \textbf{peaceful} if no atomic package constraint in the
  conflicts of any package $p\in S$ is satisfied by $dom(S-\{p\})\cup
  pro(S-\{p\})$,
\end{itemize}
A subset $S$  of the universe of $U$ satisfies a request
\begin{itemize}
\item \PROP{install} $\phi$ if every atomic constraint
  in $\phi$ is satisfied by $dom(S)\cup pro(S)$;
\item \PROP{remove} $\phi$ if no element of $\phi$ is
  satisfied by $dom(S)\cup pro(S)$.
\end{itemize}
$S$ is a solution if it is abundant, healthy, and satisfies the
request. Note that a solution is allowed to contain several packages
with the same name (which then have to differ in version). Also, there
is a subtlety in the definition of health, in that a package (and the
packages provided by it) are not taken into account when evaluating
its own conflicts.

The full formal semantics of CUDF is given in~\ref{sec:cudf-semantics}.
