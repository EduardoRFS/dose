\section{Cudf 2.0 Encoding}

Debian packages can be represented by a tuple composed of name,
version, architecture, multiarch, depends, conflicts, provides. Let
\names{} be a set of names, \architectures{} a set of architecture
names and \versions{} be an ordered set of version strings. The exact
nature of versions are not important for our purpose safe, the
knowledge that a closed set of Debian versions can be safely
associated with an ordered set of cudf versions. We define the set of
multi-architecture identifiers as $\cal{M} = \{ \texttt{None, Same,
Allowed,Foreign} \}$.

A \emph{constraint} is a unary predicate on versions: for any $v \in
\versions$ we may write constraints $=v$, $\neq v$, $<v$, $>v$, $\leq
v$, and $\geq v$.  A constraint is used in order to refine a
dependency or a conflict relation between packages. The set of
constraints is denoted by $\con$.

\begin{definition} 
  A Debian \emph{package} $p$ is a tuple $(n,v,a,m,D,C,P)$ consisting of:
  \begin{itemize}
    \item a {\rm package name} $n \in \names$,
    \item a {\em version} $v \in \versions$,
    \item a {\em architecture name} $a \in \architectures{}$,
    \item a {\em multi-arch identifier} $m \in \multiarchs{M}$,
    \item a set of dependencies $D \in\power{\power{\names\times\con}}$,
    \item a set of conflicts $C \in\power{\names\times\con}$.
    \item a set of provides $C \in\power{\names\times \{ = \} }$.
  \end{itemize}
\end{definition}
where we use $\power{X}$ for the set of all subsets of $X$.

\begin{definition}{Order on versions.}
  We assume a order $\leq$ on $\versions$ that is :
  \begin{itemize}
    \item Total: $\forall x,y : x < y \Or x=y \Or x > y$
    \item Dense: $\forall x,z : z < z \rightarrow \exists y : x < y < z$
  \end{itemize}
\end{definition}

Totality means that we can always compare two versions, while density
means that given any two versions, we can always find a third one in
between. This ordering function will allow us, given a Debian
repository, to associate to each Debian version a cudf version (that
is, an integer).

\begin{definition}{Satisfaction of constraints.}
  Given a versions $v \in \versions$ and a constraint $c \in \con$, we
  write $v \models c$ when the version $v$ satisfies the constraints $c$.
\end{definition}

For example, $3.1 \models (\geq,1.4)$ and $3.7 \not\models (<,2.1)$

\begin{definition}{Package Constraints.} 
  A package constraint $(n,c) \in \names\times\con $ is a pair of
  package name and version constraints. 
\end{definition}

\begin{definition}
  For a set of packages $P$ we define
  \[
    \begin{array}{lcl}
      \dep{P} & := & \bigcup_{d \in \dependency{p}} d \\
    \end{array}
  \]
\end{definition}

That is, $\dep{P}$ is the set of all pairs of names and constraints
occurring in dependencies in $P$, We abbreviate $\dep{\{p\}}$ to
$\dep{p}$.  A Debian repository is a set of Debian packages that are
uniquely identified by package name, version, and architecture name :

\begin{definition}
  \label{def:repository}
  A \emph{repository} is a set $R$ of packages such that for all $p, q
  \in R$: if $\name{p}=\name{q}$ and $\version{p}=\version{q}$ and 
  $\arch{p}=\arch{q}$ then $p=q$.
\end{definition}

We use the infix notation $(.)$ to access individual package
components (e.g.~$p.n$ stands for the name of package $p$). This
notion extends to sets of packages, e.g.~$R.n$ is the set of names of
packages in the repository $R$.

\begin{definition}
    Given a repository $R$ and a package constraint (n,c), the
    semantics of (n,c,) with respect to $R$ is
    \[
      [[(n,c)]]_R = 
      \{ p \in R \mid n \in \provides{p} \cup \{ \name{p} \} \And \version{p} \models c \}
    \]
    that is: the set of packages whose name is n and whose version
    satisfies $c$.
\end{definition}

In this section we will present the encoding of a Debian repository to
a cudf repository. Clearly this is not the only possible encoding. To
reduce to a minimum the changes required to encode the multi
architecture semantic into cudf, we chose to encode the
multi-architecture dependency logic into provides and adding
co-installability constraints using conflicts. This choice implies the
creation of many distinct provides and conflicts, one for each
known architecture. At the same time, by using constraints like
$\neq$, we avoid expanding conflicts and provides to a list of real
packages. We think that the chosen encoding strikes a careful balance
between readability and conciseness.

\paragraph{Uniqueness.}
Given a Debian repository, packages are uniquely identified by name,
version and architecture. Cudf packages, on the other, hand are
identified by a tuple, namely $(\name{p},\version{p})$. To encode
Debian packages in cudf 2.0 without hampering readability, cudf
packages are written as $("\name{p}:\arch{p}",\version{p})$, therefore
identifying the corresponding cudf package by concatenating name with
the architecture using the character ``:'' as separator.
\footnote{Note that since the character ``:'' is not part of the
character sets used to denote cudf packages, it will be encoded in a
cudf document as its hexadecimal encoding ``\%\ldots''.}

We define the set of foreign plus the native architecture as $\cal{A}$.

We define a generic function to transform package constraints.
\begin{definition}
  We define the function 
  $\gamma : \power{\names\times\con} \rightarrow \power{\names_{cudf}\times\con}$ :

  \[
    \gamma ((n,c),a,na) = \left\{ 
      \begin{array}{rl}
        (n:na,c) & \mbox{ if } a = \tt{all} \\
        (n:a,c)  & \mbox{ otherwise }
      \end{array} 
    \right.
  \]
\end{definition}

\paragraph{Dependencies : \texttt{None, Same, Allowed,Foreign}.}
Given a Debian repository, and a package $p$ the set of dependencies
$p.D$ is encoded in the same way for all multi-architecture cases. For
each constraint $(n,c) \in p.D$ we create a cudf constraint of the
form $(n:\arch{p},c)$. This constraints enforce the fact that this
dependency must be satisfied by a package providing a name
$n:\arch{p}$.

To this general rule there are two exception. The first is that if the
dependency has the form $(n:any,c)$, then the we do not append the
package architecture : the dependency should be satisfied by ``any''
package providing the name $n$ (that is a cudf package providing the name
$n:any$). Secondly, if the architecture of the package
is of type \texttt{all}, then we append to all dependencies $n$ then
native architecture. Formally we define the following function :

Given a Debian package $p$, a native architecture $na$, we define
the function 

$\phi : \power{\names\times\con} \rightarrow \power{\names_{cudf}\times\con}$ :

\[
  \phi ((n,c),a,na)) = \left\{ 
    \begin{array}{rl}
      (n,c)               & \mbox{ if } n:any \\
      \gamma((n,c),a,na)) & \mbox{ otherwise }
    \end{array} 
  \right.
\]

The set of cudf dependencies by extending the function $\phi$ to the
set $p.D$.

\paragraph{Conflicts : \texttt{None, Allowed,Foreign}.}
For all cases, except for multi architecture {\texttt Same}, are
encoded appending the package architecture to all package constraints.
Moreover, we add an additional conflict with all the packages that
provides the name $p$. 

Given a Debian package $p$, a native architecture $na$ and a set of
foreign architectures $\cal{F}$. The set of cudf constraints is
encoded as follows : 
\[
  C(p) = \{ p \} \cup \bigcup_{a \in \cal{F} \cup \{ na \} } \gamma(p.C,a,na)
\]

\paragraph{Conflicts : \texttt{Some}.}

Packages declared multi-arch \texttt{Some} are co-installable with
packages that have same version but different architectures, but they
must not be used to satisfy the dependency of any package of a
different architecture from itself. We encode these constraints by
first adding a self conflicts (that is a conflict with all packages of
any version and same architecture), a conflict with all packages with
same name but a different architecture and different version. Then for
each conflict $(n,c)$ and for each foreign architecture $a$ we add a
conflict to each real package $p$ providing the name $n$ of the form
$(p.name:a,c)$.

Given a Debian package $p$, a native architecture $na$ and a set of
foreign architectures $\cal{F}$, and let $\cal{A} = \{ na \}
\cup \cal{F}$. The set of cudf constraints is encoded as follows : 
\[
  \begin{array}{rl}
    C(p) = & \{ p \} \cup \\ 
    & \bigcup_{a \in \cal{A}} \{ (n:a:, \neq p.v) | (n,c) \in p.C \} \cup \\
    & \bigcup_{a \in \cal{A}} \{ (\name{rn}:a:,c) | (n,c) \in p.C \mbox{ and } rn \in \rel{(n,c)} \} 
  \end{array}
\]

\paragraph{Provides : \texttt{None, Some}.}

Provides are encoded appending the package architecture to the package
name as follows, with the exception of packages with architecture
\texttt{all}.

\[
  P(p) = \{ p \} \cup \gamma(p.P)
\]

\paragraph{Provides : \texttt{Foreign}.}

A package that is declared multi architecture \texttt{Foreign} cannot
be co-installed with a package with a same name architecture, but it
can be used to satisfy the dependencies of packages with different
architectures. This constraint is reflected encoding provides as
follows:

\[
  \begin{array}{rl}
    P(p) = & \{ \name{p} \} \cup \\
    & \{ \gamma((n,c), \arch{p},na) \mid (n,c) \in p.P \} \cup \\
    & \{ \gamma((n,c),a,na) \mid a \in A \setminus \{ \arch{p} \}, (n,c) \in p.P \}
   \end{array}
\]

\paragraph{Provides : \texttt{Allowed}.}
A package that is declared multi architecture \texttt{Allowed} can be
used to satisfy dependencies of type \any{}. The provides are
encoded using the following rule:

\[
  \begin{array}{rl}
    P(p) = & \{ \name{p} \} \cup \{ \name{p}:any \} \cup \\
    & \{ \gamma((n,c), \arch{p},na) \mid (n,c) \in p.P \} \cup \\
    & \{ (n:any,c) \mid (n,c) \in p.P \} 
   \end{array}
\]
